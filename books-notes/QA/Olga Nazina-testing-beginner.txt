Ольга Назина, "Что такое тестирование. Курс молодого бойца" 

~550-600 страниц, читал ~2 недели (конец декабря - 14 января, 3/4 прочитал пока сидел с котом во время праздников)


Введение + глава 1 (исследование продукта):
1. Начинаем с позитивных тестов
2. В первую очередь Узнаем суть продукта(зачем он нужен и какие проблемы решает)
3. Задавать открытые вопросы вместо закрытых
4. Тестировщик не должен додумывать, он должен уточнять
5. Главная задача тестировщика - предоставить информацию как работает приложение, а не пытаться его сломать 
6. Чем раньше найдена ошибка, тем проще её исправить
7. Вводить собеседника в контекст (насчёт логов по задаче test-8, там null pointer exception при делении на 0, что будем делать?)
8. Вопросы норм задавать ( не кучу мелких типа а что если ввести 0, -1, 100500, а например что если заказать не в диапазоне от 100 до 300, или а что если загрузить неподходящий формат?)
9. Представляться при работе с незнакомцами
10. Давать ссылку (на задачу в джире, страницу конфлюенс, репозиторий с кодом)
11. Пояснить зачем нужна эта информация, возможно подскажут более оптимальный путь решения
12. Когда что-то спрашиваешь, не забудь упомянуть что ты уже попробовал сам найти/сделать. Покажет что ты ценишь время другого человека и не отвлекаешь его на каждый чих даже если так быстрее
13. Вопросы задавать пачкой чтобы реже отвлекать коллегу, ему потом нужно будет время чтоб вернуться в состояние потока
14. Правило 20 минут, сначала попробуй решить задачу сам, если за 20 минут не нашёл решения, можно и коллегу спросить
15. Майнд карта по часовой читается, самое важное вверху справа получается (примеры хороших карт в примечании 21)


глава 2 (Тест-кейсы и чек-листы):
1. Тест должен быть конкретным (понятно что сделать и как сделать, чего ожидаем)
2. У теста должен быть результат (ожидаемого может не быть, все равно фиксируем фактический)
3. Сначала проверяем основные позитивные сценарии
4. То что функционал работает по отдельности далеко не факт что будет работать вместе
5. Негативное тестирование - делать не так, как надо - смотрим на поведение системы (попросили ввести дату, введу символы), не должно быть краша системы, выдаёт ли понятное сообщение об ошибке
6. Помимо всяких проверок текстового и числового поля, стоит проверить работу в разных вкладках браузера(тут много вариантов для проверок, актуально для ESM)
7. Граница между позитивом и негативом относительна
8. Выкидывать из названия тест кейса лишние слова (тестирование/проверка функционала загрузки файла-образца - это тест-кейс, мы в нем всегда что-нибудь проверяем, загрузка файла-образца и всё)
9. Шаги писать обезличено (нейтральные глаголы - открыть, скачать)
10. На проде не тестируем, только smoke тестирование
11. Ожидаемый результат в ТК должен быть понятным и конкретным, чтобы можно было чётко сказать работает или не работает
12. Когда длинный результат(например сформированый отчёт), надо написать на что обращать внимание (число в такой-то колонке должно быть равным сумме всех введённых значений)
13. Вложение - дополнение к проверке, не заменяет описания. Представьте что вы объясняете новичку в курилке о чем именно тест, не вспомнишь все 100500 цифр из отчёта, а пишешь логику построения. Об этом и писать
14. При тестировании фильтрации/поиска готовить данные которые не подходят по критериям чтобы проверить что фильтрация/поиск действительно работает (их не будет в результате)
15. Структура чеклиста - проверка, пример, ожидаемый результат(конкретный, описываем на что обращать внимание). Общие шаги можно вынести за скобки(перед самим чеклистом).
16. "Бывает такое, когда разработчики ставят шуточные сообщения об ошибках, чтобы перед релизом убрать. И, разумеется, о них забывают". Кое кого из наших разработчиков напоминает...
17. На типовые поля можно поискать чит-листы


глава 3 (Классы эквивалентности и граничные значения):
1. Тест-дизайн - набор техник, которые позволяют нам приложить мало усилий и получить много результата (сократить количество тестов без потери качества тестирования/покрытия)
2. Два значения называются эквивалентными когда приводят к одному результату (если проверили 2+2, то 2+3 проверять не надо)
3. Разбиение на классы на примере калькулятора (сгруппировали проверки по какому-то принципу) - простые числа, дробные через точку, дробные через запятую, тысячи, максимальное которое влезает, max + 1, max + max
4. Вся соль - выделить классы правильно
5. Эффект пестицида - если повторять одни и те же тесты снова и снова, в какой-то момент они перестанут выявлять новые ошибки (повторное применение тех же тестов и тех же методик приводит к тому, что в продукте остаются именно те дефекты, против которых эти тесты и методики неэффективны. Чтобы избежать этого, нужны каждый раз брать разные значения для тестов
6. Статья "Это ещё не конец", автор Michael Hunter - идеи для дальнейшего тестирования различные методы ввода, файлы, сетевое соединение, сообщения об ошибках (разные части статьи, где-то на software-testing есть финальный pdf)
7. Граничные значения - например дан диапазон от 0 до 11, проверяем внутри диапазона (8), сами границы (0, 11), слева и справа границ(-1, 12), далеко далеко (переполнение, например выйти за пределы int-а)
8. Границы в нецелых числах - могут быть ошибки при приближении к границе на расстояние меньше точности вычислений (0,00000000000000000000001 или 0.99999999999999999999999)
9. Границы там где "нет числа" - ищем число. Строковое поле - длина строки. Авторизован ли пользователь 1/0 это числа (не понял), загрузка отчёта - очень  мало или очень много строк, размер бассейна - тоже числа
10. Не везде можно найти границы и это нормально. Не надо их высасывать из пальца
11. Всегда проверять на 0 (не всегда число, например пустая строка, размер файла близкий к 0, 0 строк/колонок в файле)
12. Мнемоника БМВ - Большой(ищем тех границу, напиимер слишком большое число, впихиваем невпихиваемое), Маленький(около нуля), В самый раз (позитивный тест)
13. Тестируйте конкретное поле и его бизнес-смысл, а не абстрактную строку


глава 4 (тест-анализ):
1.Как выкидывать тесты - а)объединить позитивные тесты (во все 3 поля вставили норм значения, но не только для полей, разные параметры, например у файла размер, количество строк, формат; вещь в интернет магазине - категория, цвет, размер
б) выкинуть дубли - сначала генерим идеи для тестов - затем фильтруем (на начальном этапе так, потом уже сразу не будешь писать дубли)
в) не тестировать один функционал один раз (типа строку поиска которая есть на каждой странице достаточно проверить в одном месте а не на всех страницах)
2. Типичные ошибки:
а) объединять негативные тесты/проверки (иначе как понять какая именно проверка сработала)
б) пихать в один тест всё и сразу
3. Техника pairwise эффективна когда много параметров, но мало значений в каждом (инструменты allpairs, PICT). Плюсы - сильно снижает количество проводимых тестов, хорошее покрытие (найдёт столько же ошибок сколько полный перебор, но за меньшее время). Минусы - сложно локализовать баг, так как непонятно какая именно пара значений повлияла на ситуацию.


глава 5 (баг-трекинг):
1. Баг - это проблема для лиц, чьё мнение имеет для нас значение (так как ТЗ может быть не всегда, и в нём могут быть ошибки или что-то не описано, а если есть чёткое ТЗ, тогда да, определение "баг - отличие ФР от ОР" подходит
2. Баги надо заводить (блин), так как ты или разраб забудете, а если просто скажешь разрабу устно, то отвлечешь его и он потеряет ныть размышления и будет долго вспоминать че делал и что делать дальше (здесь рекомендация книги Фредерик Брукса "Мифический человек-месяц", не в первый раз вижу рекомендацию на эту книгу, надо почитать)
3. Локализация бага - поиск причины проблемы
4. Как заводить баги:
а) Локализуем проблему
б) даём короткий и ёмкий заголовок (в заголовке не должно быть слов ошибка, неправильный, некорректный, неверный так как это баг и так понятно что что-то работает не так)
в) прикладываем скриншот (желательно не всего экрана, а только нужной области + выделить на что обращать внимание, например стрелочками)
г) описываем шаги воспроизведения и результат
д) обосновать ожидаемый результат
Плюс доп поля:
е) приоритет (и мб ещё  критичность).
Приоритет - насколько критичен баг для бизнеса. Высокий приоритет - это когда задачу нужно срочно исправлять. 
Критичность - насколько критичен баг сам по себе, с технической точки зрения.
Пример высокого приоритета и низкой критичности - опечатка в имени спонсора или вашего сайта на главной странице (так как страдает репутация)
Пример низкого приоритета и высокой критичности - при очень особых плясках приложение крашится (так как очень редко будет случаться, 1 на миллион случаев)
ё) версия приложения в которой баг нашли + версия в которой нужно поправить (релиз, спринт) для планирования ресурсов на релиз и отслеживания на дашборде релиза
ж) компонент - где именно произошла ошибка. Помогает искать дубликаты, а также анализировать где больше багов
5. Лучше завести дефект даже если не уверен. Для истории (вдруг потом скажут что тестеры такой баг пропустили, хотя сами до этого говорили что все норм и это не баг)
6. 1 проблема или схожие проблемы - заводим 1 баг. Если не особо связаны то заводим отдельные баги
7. Локализация дефектов - копаем рядом (принцип лопаты, вдруг мы нашли всего одно проявление, а их сильно больше?), строим догадки и опровергаем их, не увлекаемся (правило 20 минут - сначала сами 20 минут, потом спрашиваем, эффект лентяя)
8. Пытаемся найти минимальные данные для воспроизведения бага (методом бисекционного деления то есть деление пополам, суть как в бинарном поиске)
9. Шаблон бага:
Предусловия (опционально) 
Шаги воспроизведения:
ФР:
ОР:
Заголовки выделяем жирным (шаги, ФР, ОР), нумеруем шаги, единственный шаг не надо нумеровать. Отделяет шаги от ФР и ОР пустой строкой, сначала ФР, затем ОР (но я делаю наоборот)
10. В шагах давать ссылку если она есть (плюс описание, то есть пояснить ссылку, открыть кабинет <ссылка>, открыть отчёт по прошлому месяцу <ссылка>), давать данные для авторизации (у нас не надо так делать), если локализовали дефект то в шагах пишем именно это, все лишнее уносим в доп. инфо. Например
Шаги:
В форму ввода доходов <ссылка> ввести любой символ - например "А".
Доп. инфо:
Воспроизводится также для полей:
а) расходы <ссылка>
б) процентная ставка <ссылка>
в) ...
Если воспроизводится везде то можно в шагах так и указать, но для лучшей читаемости можно в шагах оставить одно место
Не забываем про скриншоты и примеры (значения для ввода, файл, запрос)
11. Правила для вложений - говорящее имя вложения (борода у женского персонажа.jpg), ссылаться на вложение в шагах/результате (шаг 3. Отправить  запрос из вложения), удалять лишнее(минимальный файл, скриншот только проблемной зоны), использовать стрелки на скринах
12. Типовые места с ошибками - кроссбраузерность, concurrency (параллельная работа с одним и тем же приложением - разные вкладки - в одной редактируем, в другой удаляем, хорошо для тестов CRUD), валидация клиент-сервер (проверка есть только на фронте, обходишь проверку на фронте и все ломается, проверять и клиент и сервер), буква "Ё"
13. Чеклист закрытия задачи: проверить задачу, проверить что документация написана/актуализирована, в баг-трекере коммент "проверил на сборке 123, проверил то и то вручную через UI/SOAP/REST, написал такие-то автотесты(ссылка на них), приложить к задаче тестовые данные, например SOAP/SQL запрос, файл который грузил и (думаю все кроме комментария должно быть в тест -кейсе, и думаю комментарий не всегда нужен)
14. Анализировать пропущенные баги методом "5 почему", исправлять корень проблемы
15. Можно распечатать и повесить плакат НЛО (Найти, Локализовать и Оформить ошибку), но наверно не надо))


глава 6 (исследовательское тестирование):
1. Ad-hoc тестирование - тестирования без использования спецификаций, планов и тест-кейсов. Чистая импровизация
2. Исследовательское тестирование - более формальная версия ad-hoc/вдумчивый подход к ad-hoc тестированию. Это тестирование, не требующее написания ТК, но подразумевающее, что каждый последующий тест выбирается на основании результата предыдущего теста
3. Сценарное тестирование - классическое тестирование по предварительно написанным и задокументированным сценариям (ТК, чек-листы)

Туры Уиттакера:
1. Тур по деловому центру - тестирование основного функционала(киллер-фич), показывает сценарии его использования клиентами
2. Тур по путеводителю - тестирование чётко по путеводителю (руководство пользователя, раздел Help). Проверяем основные позитивные сценарии, здесь негатив не смотрим
3. Денежный тур - тестирование "продающих" функций приложения (не понял чем отличается от делового центра)
4. Тур по ориентирам - выбираешь ориентир и идёшь к нему "сквозь" приложение. Например, ориентирами могут быть функции, полученнаые в турах по путеводителю (не понял вообще этот тур)
5. Интеллектуальный тур - задаём приложению сложные вопросы, нагружаем его (заказать 200 платьев, выбрать кредитку потом передумать, оплатить часть с одной, часть с другой) - не оч понял тур. + вариация Тур высокомерного американца, вместо сложных вопросов задаём разжражающе глупые вопросы (тоже не понял)
6. Тур доставки FedEx - прослеживаем данные на каждом этапе - от входа до конца/сохранения в БД? (не понял)
7. Внеурочный тур - тестируем части поддержки и мониторинга. Что будет если грохнуть фоновый процесс? Если идёт какая-то обработка/передача данных грохнуть приложение или отрубить интернет. Нанесёт ли такое непоправимый вред (не понял этот тур). + вариация Тур утренней дороги на работу - протестировать скрипты запуска приложения
8. Тур сборщика мусора - как дворник идём по чуть-чуть(экран за экраном, диалоговое окно за диалог. окном), предпочитая кратчайший путь и останавливаемся на несколько мгновений, проверяем поверхностно (так себе понял)
9. Туры по историческим районам - проверяют старую функциональность и исправление ошибок. Исторические районы - legacy код, старый функционал, исправления багов.
10. Тур по плохому району - тестируем места(компоненты, модули) где больше всего багов было.
11. Музейный тур - проверяем места с legacy кодом, которые были недавно изменены
12. Тур предыдущей версии - по сути регрессионное тестирование
13. Туры по развлекательным районам - исследование второстепенных, нежели основных функций, позволяют убедиться что они дополняют друг друга без противоречий
14. Тур актёра второго плана - проверяем функции, которые не главные, но находятся рядом с ними (не понял чем отличается от тура по развлекательным районам)
15. Тур глухого переулка - исследование наименее используемых и привлекательных для пользователей функций. + вариация Тур смешанного места назначения - комбинируем самые знаменитые и наименее популярные места
16. Тур полуночника - исследуем как долго приложение будет работать и обрабатывать данные, не выключаем его
17. Тур чашки кофе - на каком-то проходном этапе(начали оформлять заказ в интернет магазине), уходим на 5 минут, потом возвращаемся и пытается продолжить
18. Туры по туристическим районам - делаем небольшой чек-лист для набега на некие функции приложения (не понял!)
19. Тур коллекционера - пройтись в приложении везде где только можно и задокументировать все выходные данные (не понял!)
20. Тур одинокого бизнесмена - протестировать функции, которые расположены дальше всего от точки входа в приложение (нужно пройти максимальное количество экранов)
21. Тур супермодели - проверяем только как приложение выглядит и какое первое впечатление производит. Без фокуса на функциональности и реальном взаимодействии. Только интерфейс
22. Тур "второй бесплатно" - запускаем несколько копий приложения/вкладок
23. Тур шотландского паба - протестировать функции, которые сложно найти, если заранее о них не знаешь (не понял)
24. Туры по отельным районам - тестируем второстепенные или сопутствующие основным фичам функции (опять копия другого тура)
25. Тур, отмененный из-за дождя - начать операцию и отменить/остановить её (самый норм тур)
26. Тур домоседа - делать минимум работы будто тебе скучно/лень/нет сил. Соглашаться с дефолтными значениями, оставлять поля пустыми, заполнять минимум значений
27. Тур по захудалым районам - входные данные, которые ломают приложение или как-то вредят ему (не понял! Плюс уже был похожий по описанию тур)
28. Тур саботажника - подстроить все так чтобы операция провалилась. Заставить приложение выполнять какое-то действие, понять какие ресурсы необходимы для успешного выполнения этого действия, удалить или спрятать эти ресурсы
29. Тур антисоциального типа - делать все назло, все не так как требуется. 3 подтура: opposite tour - вводить наименее хорошие данные, где только возможно. Illegal inputs - вводить данные неверного типа/формата, слишком длинные, слишком короткие и т.д., аналогичен туру по плохим районам. Wrong turn tour - выполнять действия в неправильном порядке.
30. Тур невротика - снова и снова вводить одинаковые значения, выполнять одно действие

мои туры 
1. Тур по деловому центру (тестирование основного функционала/киллер-фич) 
22. Тур "второй бесплатно" - параллельная работа (несколько копий приложения/вкладок) 
25. Тур, отмененный из-за дождя - начать операцию и отменить/остановить
29. Тур антисоциального типа - делать всё назло, не так как требуется 
Плюс возможно:
5. Интеллектуальный тур - сложные вопросы 
8. Тур сборщика мусора - идти по чуть-чуть, тут посмотрел, пошёл дальше там че-то потестил поверхностно, пошёл дальше
10. Тур по плохому району - тестируем места где больше всего багов было 
26. Тур домоседа - делать минимум работы, оставлять дефолтные значения, оставлять поля пустыми, заполнять минимум значений


глава 7 (тестирование документации)
1. Проверять пользовательскую документацию (что она норм + самим пройтись по ней) 
2. Всегда проверять примеры (файл-образец, предзаполненные поля, пример вызова API методов)
3. Письма от системы - проверяем например плейсхолдеры типа имя и дата - правильно ли подставились, а если пустым оставить поле, на другом языке, введу спецсимволы (у нас актуально, был баг в доступах со спецсимволами, два доллара в письме заменялись на один), а если очень длинное имя, правильная ли дата будет в письме, когда придёт письмо? + орфография
4. Сообщения об ошибках - проверяем что я из него пойму, смогу ли исправить ошибку, пойму вообще что я сделал не так?
5. Поп-ап сообщения - проверяем влезает ли текст (на самых мелких экранах, потом на средних, вдруг для телефонов ок а на айпад мини нет)
6. Предупреждения "что вводить" (например пароль должен быть длиннее 8 символов, содержать минимум 1 цифру и символы в разных регистрах) - желательно должны быть. Проверяем что они понятные, в мире пользователя, выполнимые
7. Инструкция по установке - если её можно избежать, то сделайте это. Должна быть максимально простой и понятной, желательно с 
8. Описание полей - хорошо если пользователю объясняется зачем ему заполнять это поле. Возле поля "укажите email" при регистрации что-нибудь вроде "чтобы мы могли прислать состояние обработки и баланс"
9. Маркетинговые материалы, обучение, FAQ, презентации - все это тоже надо проверять. Смотрим орфографию, актуально ли, понятно ли, полезно ли.
10. Тестируем документацию на -
-полнота
-однозначность
-непротиворечивость
-необходимость
-осуществимость
-тестируемость


глава 8 (создание документации: тестовой и не только)
1. Тест-план - план того что, как, когда, зачем и какими ресурсами тестируем
2. Если просят сделать отчёт о тестировании, то нужно уточнить зачем это и как будет использоваться. Присылать максимально краткий отчёт.


глава 9 (классификация тестирования):
1. По знанию системы - чёрный ящик(не знаем как система устроена внутри, нет доступа к коду или не умеем его читать), белый ящик (есть доступ к коду и тестируем его), серый ящик (совмещение)
2. По позитивности - позитивное(проверяем работу), негативное(пытаемся сломать)
3. По целям(по объекту) - функциональное(что) и нефункциональное(НФТ) (как - например быстро или медленно).
НФТ - 
А) Тестирование производительности (скорость работы, как быстро что-то отрабатывает), 
Б) Нагрузочное (много пользователей/потоков/запросов одновременно), 
В) Стресс тестирование (смотрим устойчивость системы в стрессовой ситуации, нагрузка выше нормальной), 
Г) Тестирование надёжности (стабильности) - проверяем работоспособность приложения при длительном тестировании с ожидаемым уровнем нагрузки. Цель тестирования надёжности - выяснить как долго сервис может проработать безотказно в конкретном окружении под конкретной нагрузкой(не экстремальной, а простой) и выявить утечки ресурсов
Д) usability(удобство использования) - главное правило usability:
"Если ты - не целевая аудитория продукта, то ты понятия не имеешь, что такое 'удобно', а что такое 'неудобно'!". Нужно обращать внимание на скорость обучения, скорость использования, количество пользовательских ошибок, субъективную удовлетворённость (целевой аудитории)
Е) Тестирование GUI - проверка того, что интерфейс выглядит как задумано (мб выверка по макетам, а может просто проверить что все кнопки отображаются, текст за границы не вылезает и прочее)
Ё) Тестирование безопасности - брутфорсинг(перебор), перехват трафика, SQL иньекции (поле пароль - root' OR 1=1), XSS-атаки(поле имя - Маша<script>alert("Я ТЕБЯ СЛОМАЛ АХАХА")</script>)
Ж) Тестирование локализации (перевод на разные языки) - адекватность перевода, все ли пункты меню и кнопки и рисунки переведены, влезают ли длинные фразы на другом языке + взаимодействия с пользователем (письма, нотификации, СМС) + взаимодействия с оборудованием (принтер, сканер, экспорт), переходы по страницам и обратно со сменой языка, правильно ли выбирается дефолтный язык
З) Тестирование совместимости - разные ОС, разное железо, разные браузеры, разный сторонний софт (плагины в браузер, антивирус)
4. По исполнителям (по субъекту) - альфа-тестирование (тестирует команда разработки - тестеры, разрабы, аналитики) и бета-тестирование (тестируют реальные пользователи)
5. По затраченному времени (дымовое тестирование) - smoke (дымовое) тестирование - направлено вширь чтобы проверить как можно большего функционала в кратчайшие сроки. Sanity (санитарное) тестирование направлено вглубь проверяемой функции/модуля.
Smoke можно провести после регресса на пси/проме до того как пользователи начнут пользоваться. Sanity проводится если в смоуке/регресс обнаружены какие-то баги.
Тестирование нового функционала (проверяем лишь новый функционал, проверяем старый только если уверены что он связан с новым).
Регрессионное - проверяем то, что работало раньше, работает и сейчас.
6. По степени автоматизации - ручное, автоматизированное, полуавтоматизированное
7. По состоянию системы - статическое тестирование (система не запущена, тестируем документацию, ревьювим код) и динамическое (система запущена, регистрация/ авторизация/создание заявки/загрузка файла и прочее)
8. По формальности - тестирование по готовым тестам, исследовательское тестирование.
По тестам выбираем когда очень важный или сложный модуль. Исследовательское выбираем когда замылился глаз


глава 10 (автоматизация тестирования):
1. По каким принципам отбирать тесты для автоматизации - важное, нудное, частое. Нет смысла автоматизировать функционал который ещё в разработке или часто меняется (немного спорно, но ок). Лучше автоматизировать нудный регресс, который не меняется.
2. Много багов можно найти пока просто пишешь автотесты (способ снять эффект замыленного глаза и заметить то что в упор не видел)
3. Users - бесплатное приложения для тестирования (UI + REST+ SOAP), есть специально зашитые баги - http://okiseleva.blogspot.com/2017/04/users-soap-rest.html + http://users.bugred.ru/
4. Folks - бесплатная система, чтобы пощупать API тесты https://testbase.atlassian.net/wiki/spaces/FOLKS/overview
5. Начинаем с низкоуровневых тестов и затем идём вверх. Должно быть больше низкоуровневых тестов (пирамида)
6. Автоматизация рутинной работы окупится и поможет справиться с профессиональным выгоранием
7. Инструменты полуавтоматизации - pairwise (PICT, allpairs), валидатор битых ссылок (validator.w3.org/checklink), регулярные выражения (в Notepad++, на сайтах)

глава 11 (организация процесса):
1. Не спешите менять устоявшийся процесс - Работает? Не трогай!
2. Поживите в процессе, осмотритесь. Что неудобно вам и коллегам? Опросите и запишите проблемы. Выберите самую бесящую. Предложите решение (небольшое, а не давайте все поменяем). Попробуйте с ним жить, а потом беритесь за следующую проблему.


глава 12 (как составить резюме):
1. Сделать отдельное резюме, а не просто выгрузка с HH. Плюс написать хорошее сопроводительное письмо
2. Структура резюме (именно в таком порядке) -
А) навыки + технические скиллы
Б) опыт
В) образование
Г) ключевые слова
Д) портфолио
3. Навыки - не надо писать "базовые знания ...", надо писать что самое сложное по навыку умеем делать (либо прозождение онлайн тренажёров). Например, SQL - join 3х таблиц либо 98 заданий на sql-ex, Java - прошёл 15 уровней на javarush, php - создал свой блог <ссылка на него>. Ещё лучше - портфолио с примерами работы (приложить тест-кейс, чек-лист, ссылка на github со своей программой, например задача про треугольник https://playground.learnqa.ru/puzzle/triangle )
4. Опыт - не надо писать опыт с курсов как опыт работы в компании. Надо писать релевантный опыт - самое главное в тестировании. Не в тестировании, но тоже в ИТ тоже можно писать. Можно писать достижения (построил отдел тестирования с нуля, настроил автоматизацию с нуля, ввели ревью кода и покрытие юнит-тестами)
5. Образование - указываем институт, курсы (с ссылкой на электронный сертификат при наличии). + книги по профессии в разделе Остальное или Образование. 
Прочитал книги:
- "Тестирование дот ком" Романа Савина
- ...
- + читаю Хабр и блоги, смотрю видео на YouTube
Нужно делать упражнения из книг чтоб все усваивалось
7. Указываем ключевые слова, так как резюме сначала смотрят HR (здесь нет навыка SQL, только MySQL. Выкидываем!)
8. Желательно добавить портфолио (ссылка на него) с примерами чеклистов, тест кейсов, баг репортов. Потом можно state transition diagram, нарисовать таблицу решений, но лучше это сложить отдельно. Портфолио должно занимать 2-3 листа, не слишком много. Если будет много то его не будут смотреть, цените время людей. Один лист чеклист, на втором лучшие тест кейсы, на третьем баги. Остальное можно запихнуть в папку основное. Если работодателю будет любопытно, он посмотрит, если нет - то посмотрит только остальное. Но папка Остальное все равно не должна быть свалкой. Нужно структурировать её
9. Остальное - не надо писать аккуратен, трудолюбив, усидчив.. Это само собой разумеется. Не надо писать знание Word, office.
10. Шаблоны резюме можно посмотреть на testbase.ru в разделе про навыки составления резюме (http://testbase.ru/?post_type=skill&p=51)
11. Сопроводительное письмо - может выделить из толпы. Главное правило - не пишем избитые фразы! Почему именно эта вакансия и компания, а не общее (такое которое можно отправить всем)
12. Ошибки сопроводительного письма - рассылка на всех (стандартное письмо для всех вакансий), повтор резюме, орфографические ошибки, принижение себя. Лучше писать о том что умеешь и писать позитивно, если указан какой-то навык который не знаешь - обещаем быстро разобраться(и не просто обещаем, а делаем. Обещал? Делай!). Показываем что уже начали что-то ДЕЛАТЬ (нагуглили статьи и написали первый селект, а то может только читаешь а к базе не прикасаешься). Сначала пишем а позитивном ключе. Пишем о тем, чем вы подойдёт к. А потом обещаем нагнать то, чего пока нет.
13. Как написать письмо - погуглить компанию, изучить её сайт. Почитать статьи на хабре. Написать для них, а не абстрактно. Без избитых фраз


глава 13 (собеседование):
1. Тестовое задание - хорошее на 10-30 минут опытного тестера. За бесплатный труд(более 1 часа) не браться, только ради опыта. Если задание не нравится или смущает - забить.
2. Можно попросить фидбэк на тестовое (и даже можно отправить исправленный вариант, второй шанс есть, третьего нет).
На собесе тоже можно попросить фидбэк
3. Как подготовиться к собеседованию - освежить знания по навыкам, которые указаны в вакансии. Можно сделать шпаргалку по ним (как например шпаргалка по SQL в книге, или regex или языку программирования). Заранее продумать о своих сильных и слабых сторонах чтобы не тупить когда HR будет спрашивать
4. Как проходит собеседование -рассказывают о своей компании и своём проекте, просят рассказать о себе, задают уточняющие резюме по вашему рассказу/резюме, обсуждение тестового задания которое сделали дома, дают тестовое задание, обсуждают ваше решение этого тестового, спрашивают остались ли вопросы и отвечают на них
5. Рассказ о компании - уточнить что за проект. Попросить рассказать как проходит релиз - сколько встреч(церемоний/митингов), на сколько они человек, сколько времени длятся, как часто проходят, как проходит планирование, есть ли ретроспектива, как она проходит, кто общается с пользователями, кто пишет требования, есть ли автоматизация, как она выглядит, кто занимается автоматизацией, будете ли вы заниматься ручным тестированием/автоматизацией/нагрузкой, есть ли переработки и насколько часто они возникают, какая иерархия в компании, какой вас ждёт рост - горизонтальный или вертикальный. Нужно попытаться понять что делает тестировщик на каждом этапе. Если что-то важно для вас - обязательно спрашивайте. Возможно вам не подходит стиль работы в компании, или не нравятся задачи, которые предстоит выполнять. Лучше узнать это в начале собеседования и сразу разбежаться, не тратя время. Если что-то напрягает в текущей работе, обязательно уточняйте как этот процесс проходит "у них".
6. Рассказ о себе 
7. Почему ушли с предыдущего места работы - отвечать лучше честно (спорно). Ответ про "некуда развиваться"/"хочу попробовать новое" (особенно после года работы) - не очень хороший (хотя может действительно так и есть, но в большинстве случаев можно ещё ого-го сколько развиваться)
8. Расскажите подробнее чем вы занимались
9. Расскажите про самый интересный баг/главный фейл на работе/интересный день/что-то ещё в таком роде. Помню баг Дима Т. оставил перед отпуском по РР. Задача была про загрузку праздников и выходных дней и если после загрузки праздников оказывалось что на эти дни уже запланированы какие-то задачи по РР, то нужно было их закрывать с каким-то текстом и кодом закрытия, и создавать такую же на другой день, че-то такое. Дима видимо не успевал доделать перед отпуском, поэтому написал условие что если случается такое, то zrr.doDelete() то есть просто удалял задачу. А я когда тестировал не мог понять что происходит, я же вроде создавал задачу, куда она исчезла. Потом залезли в код и увидели что условие корректное, но в таком случае не закрываем и не переносим, ничего такого. А просто удаляем задачу. А потом он все чинил и чинил и ПСИ было назначено после обеда, а до обеда ещё были баги, вернулись с обеда и ещё чинили прямо перед пси, и он чинил прям во время показа и во время показа заказчику все работало идеально
10. Если собеседующий не завёл разговор про ваше решение тестового задания, которое вы сделали дома - сделайте это сами. Получить фидбэк - бесценно.
11. Тестовое в офисе - может быть что-то вроде задачи про треугольник...ненавижу её (https://playground.learnqa.ru/puzzle/triangle и разбор https://www.learnqa.ru/triangles_answers)
12. Приходить на собес в опрятной, но обычной одежде. Спросить есть ли дресс-код
13. Не бояться и помнить, что не только компания выбирает вас, но и вы выбираете компанию
14. Если переживаешь, то сначала идти на собесы в компании, в которые НЕ хочешь попасть, или не особо хочешь. Так не страшно будет провалиться, но уже появится опыт собеседования. Чем больше собесов прошёл, тем меньше будешь переживать

глава 13 (собеседование) часть 2:
Что спросят на собесе - теорию тестирования, вопросы по навыкам, указанных в вакансии.
1. Общие вопросы
А) Какие проекты у вас оставили самые интересные воспоминания? Почему?
Б) В каких случаях применяется автоматизированное тестирование?
В) Какие книги по тестированию читали?
Г) Чем оправдано выделение роли QA в компании?
Д) Как попали в тестирование?
Е) Почему ищете новую работу?
Ё) Какой продукт сейчас тестируете?
Ж) Про один из скиллов в резюме

2. Технические вопросы
2.1. Windows
А) Где посмотреть в Windows переменные среды? Чем отличаются переменные системы от переменных среды пользователя?
Б) Как посмотреть IP-адрес компьютера?
В) Чем отличается имя компьютера от IP-адреса?

2.2 Linux
А) Как создать каталог, файл?
Б) Как понять где находишься?
В) Как посмотреть, какие процессы запущены на компьютере?
Г) Как понять, где установлено приложение?

2.3 SQL
А) Написать SQL запрос из двух таблиц
Б) Что выдаёт запрос "select * from A, B" ?
В) Что такое первичный ключ? Внешний ключ?
Г) Что такое транзакция?

3. На "поболтать"
3.1. Что вы сделали? (оценивают опыт)
А) Самый запоминающийся проект
Б) Три самых любимых проектных активности (хз можно ли сказать канбан, люблю канбан так как после него идём кушать)
В) Самая большая неудача
3.2. Что вы хотите делать? (оценивают требования к работе)
3.3. Что вы точно не хотите?
3.4. Если бы вы могли выбирать абсолютно любую работу, что бы это было? (Ухаживать за животными, и азиатками 😁)
3.5. Что вам нравится? (оценивают личность)
3.6. Какие у вас сильные и слабые стороны?
3.7. Что вы любите читать?

4. Что спрашивать вам
4.1. Расскажите о ваших процессах
4.2. Как проходит релиз?
4.3. Как выглядит ваш рабочий день?
4.4. Зарплата
4.5. Парковка
4.6. График гибкий?
4.7. Больничные оплачиваете?
4.8. За сколько надо предупреждать об отпуске?
4.9. Есть ли дресс-код
4.10. Какие задачи вам придётся выполнять (вдруг бежишь от написания документации, а тут тоже надо будет её писать) 
4.11. Как построены процессы в компании? 
4.12. Какие есть плюшки, льготы и прочее? 
4.13. Спрашивайте все, что вам интересно и важно. Задача - понять будет ли вам комфортно тут работать


глава 14 (куда развиваться):
1. В любом случае нужно:
А) Понимание цикла разработки
Б) Понимание клиент-серверной архитектуры
В) Понимать что такое БД, уметь писать SQL запросы
Г) Понимать что такое API и уметь тестировать его
Д) Навыки работы с командной строкой - перемещаться по папкам, копировать файлики, запускать приложение, архивировать файлы. Плюс почитать что такое bash/shell
2. Если хочется в разработку, идите сразу в разработку. Тестирование будет лишь потерей времени
3. Книги и ресурсы (http://okiseleva.blogspot.com/2014/02/blog-post_6.html?m=1) 
3.1. Тест-дизайн
А) Lee Copeland: "A Practioner's Guide to Software Test Design"
Б) Ron Patton: "Software Testing" 
В) James Whittaker: "Exploratory software testing"

3.2. SQL
А) Линн Бейли: "Изучаем SQL" (Head First SQL) 
Б) sql-ex.ru
В) w3schools.com/sql

3.3 Linux
А) Уильям Шоттс: "Командная строка Linux" 
Б) Скотт Граннеман: "Linux. Карманный справочник"
В) Курячий, Маслинский:  "Операционная система Linux" (не из её списка, но в комментариях к её списку книг рекомендовали эту книгу) 

3.4. Регулярные выражения
А) Бен Форта: "Регулярные выражения. 10 минут на урок"

3.5. HTML
А) Эрик и Элизабет Фримен: "Изучаем HTML, XHTML и CSS"

3.6. Версионный контроль, SDLC, CI/CD
А) Eric Sink: "Version Control by Example" 
Б) Дэн Пилон, Расс Майлз: "Управление разработкой ПО"
В) Джез Хамбл, Дейвид Фарли: "Непрерывное развёртывание ПО"

3.7 Usability
А) Алан Купер: "Психбольница в руках пациентов"
Б) Дэвид Платт: "Софт - отстой! И что с этим делать?"
В) Стив Круг: "Не заставляйте меня думать"

3.8. Остальное
Джоэл Спольски:" Джоэл о программировании" и "Джоэл. И снова о программировании"

4. Когда кажется что "некуда расти" в компании:
А) применяйте техники тест-дизайна
Б) создавайте чек-листы/чит-листы 
В) пишите документацию (хотя бы простую/краткую)
Г) улучшите процесс - почему баги на проде находятся, почему релиз не успели закрыть. Подумайте что мешало вам и попробуйте предложить решение. Подумайте что могло бы сделать вашу жизнь лучше. И сделайте
Д) учитесь автоматизации - читайте код вашего приложения, пишите автотесты, автоматизируйте рутину
Е) организуйте внутреннее обучение - хочешь разобраться в теме - изучи ее сам и объясни другому. Обучая других, вы сами лучше узнаете тему(ища ответы на каверзные вопросы например). Можно вместе с командой. Например разработчик расскажет как правильно собрать проект или как работать с VCS). Важно: теория в одно ухо влетает, в другое вылетает. Обязательно давайте практические задания своим новичкам и контролируйте их выполнение.
Увидел интересные темы их конференции - public key infrastructure; настройка гетерогенных сервисов между Oracle и mssql/excel/dbf; анализ данных (логов) с помощью grep, awk, R; Rocket science или etl средствами bash
Ё) соберите книжный клуб - можно читать одна книгу в параллель, а потом обсуждать её. Кто что вынес для себя интересного? Можно собираться за обедом


глава 15 (всё обо всем):
1. Сложные ИТ-термины на простом языке - http://testbase.ru/books/it-terms
2. Требование "знание Linux" в вакансиях - никто не ждёт от вас глубоких знаний Unix систем - как они внутри устроены, как их администрировать и прочее (но мне самому интересно). Вам нужно просто уметь выполнять простые операции: посмотреть логи через терминал, забрал их к себе, создать архив, скопировать файлик, переместить файлик, запустить службу и так далее. Можно установить на виртуалку или WSL или купить облачную машину, например на SimpleCloud за 150р в месяц. И подключаться через Putty/WinSCP
3. Применение regex для тестеров:
А) найти все нужные файлы в папке
Б) grep-нуть логи - отсечь все лишнее и найти только ту информацию, которая вам сейчас интересна
В) проверить по базе, нет ли явно некорректных записей: не остались ли тестовые данные в продакшене? Не присылает ли смежнач система какую-то фигню вместо нормальных данных?
Г) проверить данные чужой системы, если она выгружается их в файл
Д) вывермть файлик текстов для сайта - нет ли там дублирования слов?
Можно тестить регулярки если используются в коде приложения.
"У разработчика была одна проблема, и он стал её решать с помощью регулярных выражений. Теперь у него две проблемы"

4. Портфолио
А) Работа с API - возьмите любой бесплатный проект и напишите автотесты на его API методы. Аэв портфолио вставьте ссылку на коллекцию Postman или на файл для SoapUI. Можно все это дело сохранить на github. 
Бесплатные проекты для тестирования, например Users - http://testbase.ru/test-it
Курс Назиной по автоматизации в Postman - youtube.com/c/okiseleva
Б) SQL - по нему портфолио делать не надо, просто потренироваться и прописать в резюме самые сложное, что умеешь делать
В) Linux - в портфолио писать примеры не надо. Просто потренироваться выполнять обычные действия


Заключение:
1. С чего начинать тестирование:
А) изучить требования
Б) протестировать их - полнота, однозначность, непротиворечивость, необходимость, осуществимость, тестируемость. + а точно ли мы решаем проблему? Нет ли способа проще и лучше? Новый функционал - для кого? С какой целью? Зная цель, можно понять насколько хорошо она достигается
В) написать чеклист проверок (лучше попробовать написать до реализации)
Г) протестировать систему
Д) оформить результат - баг-репорты, отчёт

2. Пропустили баг - проводите его ретроспективу